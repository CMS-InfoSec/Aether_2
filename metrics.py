"""Shared Prometheus metrics and tracing helpers for microservices."""

from __future__ import annotations

from contextlib import contextmanager, nullcontext
from contextvars import ContextVar
from typing import Dict, Generator, Optional
from uuid import uuid4

from fastapi import FastAPI, Request, Response
from prometheus_client import (
    CONTENT_TYPE_LATEST,
    CollectorRegistry,
    Counter,
    Gauge,
    Histogram,
    generate_latest,
)
from starlette.middleware.base import BaseHTTPMiddleware

try:  # pragma: no cover - OpenTelemetry may be optional in some deployments
    from opentelemetry import trace
    from opentelemetry.trace import Span, SpanKind
except Exception:  # pragma: no cover - fall back to no-op tracing
    trace = None  # type: ignore
    Span = object  # type: ignore
    SpanKind = None  # type: ignore


_REGISTRY = CollectorRegistry()

_trades_submitted_total = Counter(
    "trades_submitted_total",
    "Total number of trades successfully submitted.",
    ["service"],
    registry=_REGISTRY,
)

_trades_rejected_total = Counter(
    "trades_rejected_total",
    "Total number of trades rejected during validation.",
    ["service", "reason"],
    registry=_REGISTRY,
)

_trade_rejections_total = Counter(
    "trade_rejections_total",
    "Total number of trades rejected by risk evaluation.",
    ["service", "account", "symbol"],
    registry=_REGISTRY,
)

_rejected_intents_total = Counter(
    "rejected_intents_total",
    "Number of intents rejected during the sequencing pipeline.",
    ["service", "stage", "reason"],
    registry=_REGISTRY,
)

_safe_mode_triggers_total = Counter(
    "safe_mode_triggers_total",
    "Number of times safe mode has been engaged.",
    ["service", "reason"],
    registry=_REGISTRY,
)

_oms_errors_total = Counter(
    "oms_errors_total",
    "Total number of errors returned by the OMS.",
    ["service", "account", "symbol", "transport"],
    registry=_REGISTRY,
)

_oms_auth_failures_total = Counter(
    "oms_auth_failures_total",
    "Number of authentication or authorization failures encountered by the OMS API.",
    ["service", "reason"],
    registry=_REGISTRY,
)

_oms_child_orders_total = Counter(
    "oms_child_orders_total",
    "Number of child orders generated by the OMS.",
    ["service", "account", "symbol", "transport"],
    registry=_REGISTRY,
)

_oms_stale_feed_total = Counter(
    "oms_stale_feed_total",
    "Number of OMS operations impacted by stale data feeds.",
    ["service", "account", "symbol", "source", "action"],
    registry=_REGISTRY,
)

_oms_latency_ms = Gauge(
    "oms_latency_ms",
    "Current latency of OMS interactions in milliseconds.",
    ["service", "account", "symbol", "transport"],
    registry=_REGISTRY,
)

_pipeline_latency_ms = Gauge(
    "pipeline_latency_ms",
    "Current latency of the trading decision pipeline in milliseconds.",
    ["service"],
    registry=_REGISTRY,
)

_scaling_oms_replicas = Gauge(
    "scaling_oms_replicas",
    "Current OMS replica count recorded by the scaling controller.",
    ["service"],
    registry=_REGISTRY,
)

_scaling_gpu_nodes = Gauge(
    "scaling_gpu_nodes",
    "Number of GPU nodes the scaling controller believes are provisioned.",
    ["service"],
    registry=_REGISTRY,
)

_scaling_pending_training_jobs = Gauge(
    "scaling_pending_training_jobs",
    "Pending training jobs observed by the scaling controller.",
    ["service"],
    registry=_REGISTRY,
)

_scaling_evaluation_duration_seconds = Histogram(
    "scaling_evaluation_duration_seconds",
    "Duration of scaling controller evaluation cycles in seconds.",
    ["service"],
    registry=_REGISTRY,
    buckets=(0.1, 0.25, 0.5, 1, 2, 5, 10, float("inf")),
)

_scaling_evaluations_total = Counter(
    "scaling_evaluations_total",
    "Total number of scaling controller evaluations executed.",
    ["service"],
    registry=_REGISTRY,
)

_policy_abstention_rate = Gauge(
    "policy_abstention_rate",
    "Observed abstention rate from policy decisions.",
    ["service", "account", "symbol"],
    registry=_REGISTRY,
)

_policy_drift_score = Gauge(
    "policy_drift_score",
    "Policy drift score per account and symbol.",
    ["service", "account", "symbol"],
    registry=_REGISTRY,
)

_fees_nav_pct = Gauge(
    "fees_nav_pct",
    "Percentage of fees to net asset value for risk evaluation.",
    ["service", "account", "symbol"],
    registry=_REGISTRY,
)

_policy_inference_latency = Histogram(
    "policy_inference_latency",
    "Latency distribution for policy inference in milliseconds.",
    ["service"],
    registry=_REGISTRY,
    buckets=(5, 10, 25, 50, 100, 250, 500, 1000, float("inf")),
)

_risk_validation_latency = Histogram(
    "risk_validation_latency",
    "Latency distribution for risk validation in milliseconds.",
    ["service"],
    registry=_REGISTRY,
    buckets=(5, 10, 25, 50, 100, 250, 500, 1000, float("inf")),
)

_oms_submit_latency = Histogram(
    "oms_submit_latency",
    "Latency distribution for submitting intents to the OMS in milliseconds.",
    ["service", "transport"],
    registry=_REGISTRY,
    buckets=(5, 10, 25, 50, 100, 250, 500, 1000, float("inf")),
)

_late_events_total = Counter(
    "late_events_total",
    "Number of market data events that exceeded the lateness watermark.",
    ["service", "stream"],
    registry=_REGISTRY,
)

_reorder_buffer_depth = Gauge(
    "reorder_buffer_depth",
    "Current depth of the event reordering buffer.",
    ["service", "stream"],
    registry=_REGISTRY,
)

_METRICS: Dict[str, Counter | Gauge | Histogram] = {
    "trades_submitted_total": _trades_submitted_total,
    "trades_rejected_total": _trades_rejected_total,
    "trade_rejections_total": _trade_rejections_total,
    "rejected_intents_total": _rejected_intents_total,
    "safe_mode_triggers_total": _safe_mode_triggers_total,
    "oms_errors_total": _oms_errors_total,
    "oms_auth_failures_total": _oms_auth_failures_total,
    "oms_child_orders_total": _oms_child_orders_total,
    "oms_stale_feed_total": _oms_stale_feed_total,
    "oms_latency_ms": _oms_latency_ms,
    "pipeline_latency_ms": _pipeline_latency_ms,
    "policy_abstention_rate": _policy_abstention_rate,
    "policy_drift_score": _policy_drift_score,
    "fees_nav_pct": _fees_nav_pct,
    "policy_inference_latency": _policy_inference_latency,
    "risk_validation_latency": _risk_validation_latency,
    "oms_submit_latency": _oms_submit_latency,
    "late_events_total": _late_events_total,
    "reorder_buffer_depth": _reorder_buffer_depth,
    "scaling_oms_replicas": _scaling_oms_replicas,
    "scaling_gpu_nodes": _scaling_gpu_nodes,
    "scaling_pending_training_jobs": _scaling_pending_training_jobs,
    "scaling_evaluation_duration_seconds": _scaling_evaluation_duration_seconds,
    "scaling_evaluations_total": _scaling_evaluations_total,
}

_INITIALISED = False
_SERVICE_NAME = "service"
_REQUEST_ID: ContextVar[Optional[str]] = ContextVar("request_id", default=None)


def _service_value(service: Optional[str] = None) -> str:
    value = service or _SERVICE_NAME or "service"
    return value


def _normalised(value: Optional[str], default: str) -> str:
    if value and value.strip():
        return value.strip()
    return default


class RequestTracingMiddleware(BaseHTTPMiddleware):
    """Starlette middleware that wires request IDs and tracing spans."""

    def __init__(self, app: FastAPI, service_name: str):
        super().__init__(app)
        self._service_name = service_name
        self._tracer = trace.get_tracer(service_name) if trace else None
        self._span_kind = SpanKind.SERVER if SpanKind else None

    async def dispatch(self, request: Request, call_next):
        request_id = request.headers.get("x-request-id") or str(uuid4())
        token = _REQUEST_ID.set(request_id)

        span_cm = (
            self._tracer.start_as_current_span(
                f"{self._service_name}.request", kind=self._span_kind
            )
            if self._tracer
            else nullcontext(None)
        )

        with span_cm as span:  # type: ignore[assignment]
            if span:
                span.set_attribute("service.name", self._service_name)
                span.set_attribute("request.id", request_id)
                span.set_attribute("http.method", request.method)
                span.set_attribute("http.url", str(request.url))

            response = await call_next(request)
            if span:
                span.set_attribute("http.status_code", response.status_code)

        _REQUEST_ID.reset(token)
        response.headers["x-request-id"] = request_id
        return response


def init_metrics(service_name: str = "service") -> Dict[str, Counter | Gauge | Histogram]:
    """Initialise metrics once and store the configured service name."""

    global _INITIALISED, _SERVICE_NAME
    _SERVICE_NAME = _normalised(service_name, "service")
    if not _INITIALISED:
        _INITIALISED = True

    # Prime the core series so they appear immediately for the service.
    _trades_submitted_total.labels(service=_service_value())
    _trades_rejected_total.labels(service=_service_value(), reason="unknown")
    _trade_rejections_total.labels(
        service=_service_value(), account="unknown", symbol="unknown"
    )
    _rejected_intents_total.labels(
        service=_service_value(), stage="unknown", reason="unknown"
    )
    _safe_mode_triggers_total.labels(service=_service_value(), reason="unknown")
    _oms_errors_total.labels(
        service=_service_value(), account="unknown", symbol="unknown", transport="unknown"
    )
    _oms_auth_failures_total.labels(
        service=_service_value(), reason="unknown"
    )
    _oms_child_orders_total.labels(
        service=_service_value(), account="unknown", symbol="unknown", transport="unknown"
    )
    _oms_latency_ms.labels(
        service=_service_value(), account="unknown", symbol="unknown", transport="unknown"
    )
    _pipeline_latency_ms.labels(service=_service_value())
    _policy_abstention_rate.labels(
        service=_service_value(), account="unknown", symbol="unknown"
    )
    _policy_drift_score.labels(
        service=_service_value(), account="unknown", symbol="unknown"
    )
    _fees_nav_pct.labels(
        service=_service_value(), account="unknown", symbol="unknown"
    )
    _policy_inference_latency.labels(service=_service_value())
    _risk_validation_latency.labels(service=_service_value())
    _oms_submit_latency.labels(service=_service_value(), transport="unknown")
    _late_events_total.labels(service=_service_value(), stream="unknown")
    _reorder_buffer_depth.labels(service=_service_value(), stream="unknown").set(0)
    _scaling_oms_replicas.labels(service=_service_value()).set(0)
    _scaling_gpu_nodes.labels(service=_service_value()).set(0)
    _scaling_pending_training_jobs.labels(service=_service_value()).set(0)
    _scaling_evaluation_duration_seconds.labels(service=_service_value()).observe(0)
    _scaling_evaluations_total.labels(service=_service_value())

    return _METRICS


def setup_metrics(app: FastAPI, service_name: str = "service") -> None:
    """Attach Prometheus /metrics endpoint and tracing middleware."""

    init_metrics(service_name)

    if not any(
        getattr(middleware, "cls", None) is RequestTracingMiddleware
        for middleware in app.user_middleware
    ):
        app.add_middleware(RequestTracingMiddleware, service_name=_SERVICE_NAME)

    if not any(route.path == "/metrics" for route in app.routes):
        @app.get("/metrics")
        async def metrics_endpoint() -> Response:  # pragma: no cover - simple I/O
            payload = generate_latest(_REGISTRY)
            return Response(payload, media_type=CONTENT_TYPE_LATEST)


def increment_trades_submitted(
    amount: float = 1.0,
    *,
    service: Optional[str] = None,
) -> None:
    _trades_submitted_total.labels(service=_service_value(service)).inc(amount)


def increment_trades_rejected(
    amount: float = 1.0,
    *,
    reason: str = "unknown",
    service: Optional[str] = None,
) -> None:
    _trades_rejected_total.labels(
        service=_service_value(service), reason=_normalised(reason, "unknown")
    ).inc(amount)


def increment_late_events(
    stream: str,
    amount: float = 1.0,
    *,
    service: Optional[str] = None,
) -> None:
    _late_events_total.labels(
        service=_service_value(service), stream=_normalised(stream, "unknown")
    ).inc(amount)


def set_reorder_buffer_depth(
    stream: str, depth: int, *, service: Optional[str] = None
) -> None:
    _reorder_buffer_depth.labels(
        service=_service_value(service), stream=_normalised(stream, "unknown")
    ).set(depth)


def increment_trade_rejection(
    account_id: str,
    symbol: str,
    *,
    service: Optional[str] = None,
) -> None:
    _trade_rejections_total.labels(
        service=_service_value(service),
        account=_normalised(account_id, "unknown"),
        symbol=_normalised(symbol, "unknown"),
    ).inc()
    increment_trades_rejected(service=service, reason="risk")


def increment_rejected_intents(
    stage: str,
    reason: str,
    *,
    service: Optional[str] = None,
) -> None:
    _rejected_intents_total.labels(
        service=_service_value(service),
        stage=_normalised(stage, "unknown"),
        reason=_normalised(reason, "unknown"),
    ).inc()


def increment_safe_mode_triggers(
    reason: str,
    *,
    service: Optional[str] = None,
) -> None:
    _safe_mode_triggers_total.labels(
        service=_service_value(service), reason=_normalised(reason, "unknown")
    ).inc()


def increment_oms_errors(
    *,
    account: str = "unknown",
    symbol: str = "unknown",
    transport: str = "unknown",
    amount: float = 1.0,
    service: Optional[str] = None,
) -> None:
    _oms_errors_total.labels(
        service=_service_value(service),
        account=_normalised(account, "unknown"),
        symbol=_normalised(symbol, "unknown"),
        transport=_normalised(transport, "unknown"),
    ).inc(amount)


def increment_oms_error_count(
    account: str,
    symbol: str,
    transport: str,
    *,
    service: Optional[str] = None,
) -> None:
    increment_oms_errors(
        account=account, symbol=symbol, transport=transport, service=service
    )


def increment_oms_auth_failures(
    *, reason: str, service: Optional[str] = None
) -> None:
    _oms_auth_failures_total.labels(
        service=_service_value(service), reason=_normalised(reason, "unknown")
    ).inc()


def increment_oms_child_orders_total(
    account: str,
    symbol: str,
    transport: str,
    *,
    service: Optional[str] = None,
    count: float = 1.0,
) -> None:
    _oms_child_orders_total.labels(
        service=_service_value(service),
        account=_normalised(account, "unknown"),
        symbol=_normalised(symbol, "unknown"),
        transport=_normalised(transport, "unknown"),
    ).inc(count)


def increment_oms_stale_feed(
    account: str,
    symbol: str,
    *,
    source: str,
    action: str,
    service: Optional[str] = None,
) -> None:
    _oms_stale_feed_total.labels(
        service=_service_value(service),
        account=_normalised(account, "unknown"),
        symbol=_normalised(symbol, "unknown"),
        source=_normalised(source, "unknown"),
        action=_normalised(action, "unknown"),
    ).inc()


def set_oms_latency(
    latency_ms: float,
    *,
    account: str = "unknown",
    symbol: str = "unknown",
    transport: str = "unknown",
    service: Optional[str] = None,
) -> None:
    _oms_latency_ms.labels(
        service=_service_value(service),
        account=_normalised(account, "unknown"),
        symbol=_normalised(symbol, "unknown"),
        transport=_normalised(transport, "unknown"),
    ).set(latency_ms)


def record_oms_latency(
    account: str,
    symbol: str,
    transport: str,
    latency_ms: float,
    *,
    service: Optional[str] = None,
) -> None:
    set_oms_latency(
        latency_ms,
        account=account,
        symbol=symbol,
        transport=transport,
        service=service,
    )
    observe_oms_submit_latency(latency_ms, transport=transport, service=service)


def record_ws_latency(
    account: str,
    symbol: str,
    latency_ms: float,
    *,
    transport: str = "websocket",
    service: Optional[str] = None,
) -> None:
    """Record latency observations for Kraken acknowledgements by transport."""

    set_oms_latency(
        latency_ms,
        account=account,
        symbol=symbol,
        transport=transport,
        service=service,
    )


def set_pipeline_latency(latency_ms: float, *, service: Optional[str] = None) -> None:
    _pipeline_latency_ms.labels(service=_service_value(service)).set(latency_ms)


def observe_policy_inference_latency(
    latency_ms: float,
    *,
    service: Optional[str] = None,
) -> None:
    _policy_inference_latency.labels(service=_service_value(service)).observe(latency_ms)


def observe_risk_validation_latency(
    latency_ms: float,
    *,
    service: Optional[str] = None,
) -> None:
    _risk_validation_latency.labels(service=_service_value(service)).observe(latency_ms)


def observe_oms_submit_latency(
    latency_ms: float,
    *,
    transport: str = "unknown",
    service: Optional[str] = None,
) -> None:
    _oms_submit_latency.labels(
        service=_service_value(service), transport=_normalised(transport, "unknown")
    ).observe(latency_ms)


def record_oms_submit_ack(
    account: str,
    symbol: str,
    latency_ms: float,
    *,
    transport: str | None = None,
    service: Optional[str] = None,
) -> None:
    """Record metrics for OMS submission acknowledgements."""

    resolved_transport = transport or "unknown"
    set_oms_latency(
        latency_ms,
        account=account,
        symbol=symbol,
        transport=resolved_transport,
        service=service,
    )
    observe_oms_submit_latency(
        latency_ms, transport=resolved_transport, service=service
    )


def record_abstention_rate(
    account_id: str,
    symbol: str,
    value: float,
    *,
    service: Optional[str] = None,
) -> None:
    _policy_abstention_rate.labels(
        service=_service_value(service),
        account=_normalised(account_id, "unknown"),
        symbol=_normalised(symbol, "unknown"),
    ).set(value)


def record_drift_score(
    account_id: str,
    symbol: str,
    value: float,
    *,
    service: Optional[str] = None,
) -> None:
    _policy_drift_score.labels(
        service=_service_value(service),
        account=_normalised(account_id, "unknown"),
        symbol=_normalised(symbol, "unknown"),
    ).set(value)


def record_fees_nav_pct(
    account_id: str,
    symbol: str,
    value: float,
    *,
    service: Optional[str] = None,
) -> None:
    _fees_nav_pct.labels(
        service=_service_value(service),
        account=_normalised(account_id, "unknown"),
        symbol=_normalised(symbol, "unknown"),
    ).set(value)


def record_scaling_state(
    *,
    oms_replicas: int,
    gpu_nodes: int,
    pending_jobs: int,
    service: Optional[str] = None,
) -> None:
    labels = {"service": _service_value(service)}
    _scaling_oms_replicas.labels(**labels).set(max(oms_replicas, 0))
    _scaling_gpu_nodes.labels(**labels).set(max(gpu_nodes, 0))
    _scaling_pending_training_jobs.labels(**labels).set(max(pending_jobs, 0))


def observe_scaling_evaluation(
    duration_seconds: float, *, service: Optional[str] = None
) -> None:
    labels = {"service": _service_value(service)}
    _scaling_evaluation_duration_seconds.labels(**labels).observe(max(duration_seconds, 0.0))
    _scaling_evaluations_total.labels(**labels).inc()


def get_request_id() -> Optional[str]:
    """Return the current request identifier, if available."""

    return _REQUEST_ID.get()


@contextmanager
def traced_span(name: str, **attributes: object) -> Generator[Optional[Span], None, None]:
    """Create a child span that automatically injects the request ID."""

    tracer = trace.get_tracer(_SERVICE_NAME) if trace else None
    if tracer is None:
        yield None
        return

    with tracer.start_as_current_span(name) as span:
        request_id = get_request_id()
        if request_id:
            span.set_attribute("request.id", request_id)
        span.set_attribute("service.name", _SERVICE_NAME)
        for key, value in attributes.items():
            span.set_attribute(key, value)
        yield span


__all__ = [
    "init_metrics",
    "setup_metrics",
    "increment_trades_submitted",
    "increment_trades_rejected",
    "increment_trade_rejection",
    "increment_rejected_intents",
    "increment_safe_mode_triggers",
    "increment_oms_errors",
    "increment_oms_error_count",
    "increment_oms_auth_failures",
    "increment_oms_child_orders_total",
    "increment_oms_stale_feed",
    "set_oms_latency",
    "record_oms_latency",
    "set_pipeline_latency",
    "observe_policy_inference_latency",
    "observe_risk_validation_latency",
    "observe_oms_submit_latency",
    "record_abstention_rate",
    "record_drift_score",
    "record_fees_nav_pct",
    "record_scaling_state",
    "observe_scaling_evaluation",
    "get_request_id",
    "traced_span",
]
