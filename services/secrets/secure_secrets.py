"""Envelope encryption helpers for Kraken secrets."""
from __future__ import annotations

import base64
import json
import logging
import os
from dataclasses import dataclass
from datetime import datetime, timezone
from typing import Any, ClassVar, Dict, Iterable, Optional

from cryptography.hazmat.primitives.ciphers.aead import AESGCM

LOGGER = logging.getLogger(__name__)


class EncryptionError(RuntimeError):
    """Raised when encryption or decryption fails."""


def _b64encode(data: bytes) -> str:
    return base64.b64encode(data).decode("ascii")


def _b64decode(data: str) -> bytes:
    return base64.b64decode(data.encode("ascii"))


def _serialize_context(context: Optional[Dict[str, str]]) -> bytes:
    if not context:
        return b""
    return json.dumps(dict(sorted(context.items())), separators=(",", ":")).encode("utf-8")


@dataclass
class DataKey:
    """Representation of a data key generated by the local KMS emulator."""

    plaintext: bytes
    encrypted: bytes
    kms_key_id: str
    context: bytes


class LocalKMSEmulator:
    """Simple AES-GCM based KMS emulator for envelope encryption.

    The emulator derives its master key from ``LOCAL_KMS_MASTER_KEY`` if provided.
    The value must be base64 encoded. When the environment variable is missing, a
    deterministic key is derived from ``LOCAL_KMS_KEY_ID`` to keep behaviour
    stable across restarts in development environments.
    """

    default_key_id: ClassVar[str] = "local/aether-secrets"

    def __init__(self, *, key_id: str | None = None, master_key: Optional[bytes] = None) -> None:
        self.key_id = key_id or os.getenv("LOCAL_KMS_KEY_ID", self.default_key_id)
        if master_key is None:
            env_value = os.getenv("LOCAL_KMS_MASTER_KEY")
            if env_value:
                try:
                    master_key = base64.b64decode(env_value)
                except Exception as exc:  # pragma: no cover - defensive guard
                    raise EncryptionError("Invalid LOCAL_KMS_MASTER_KEY value") from exc
            else:
                master_key = base64.b64decode(_b64encode(self.key_id.encode("utf-8")))
        if len(master_key) not in (16, 24, 32):
            # Expand shorter keys deterministically for AES compatibility
            master_key = (master_key * (32 // len(master_key) + 1))[:32]
        self._master_key = master_key

    def _aesgcm(self) -> AESGCM:
        return AESGCM(self._master_key)

    def generate_data_key(
        self,
        *,
        key_id: Optional[str] = None,
        context: Optional[Dict[str, str]] = None,
    ) -> DataKey:
        kms_key_id = key_id or self.key_id
        context_bytes = _serialize_context(context)
        plaintext = os.urandom(32)
        nonce = os.urandom(12)
        aesgcm = self._aesgcm()
        encrypted = nonce + aesgcm.encrypt(nonce, plaintext, context_bytes)
        return DataKey(plaintext=plaintext, encrypted=encrypted, kms_key_id=kms_key_id, context=context_bytes)

    def decrypt_data_key(self, *, encrypted: bytes, context: Optional[Dict[str, str]] = None) -> bytes:
        context_bytes = _serialize_context(context)
        nonce, ciphertext = encrypted[:12], encrypted[12:]
        aesgcm = self._aesgcm()
        return aesgcm.decrypt(nonce, ciphertext, context_bytes)


@dataclass
class EncryptedSecretEnvelope:
    """Container describing an encrypted Kraken credential pair."""

    kms_key_id: str
    encrypted_data_key: bytes
    encryption_context: bytes
    api_key_nonce: bytes
    api_key_ciphertext: bytes
    api_secret_nonce: bytes
    api_secret_ciphertext: bytes
    version: str = "v1"

    def to_secret_data(self) -> Dict[str, str]:
        return {
            "encryption_version": _b64encode(self.version.encode("utf-8")),
            "kms_key_id": _b64encode(self.kms_key_id.encode("utf-8")),
            "encrypted_data_key": _b64encode(self.encrypted_data_key),
            "encryption_context": _b64encode(self.encryption_context),
            "encrypted_api_key": _b64encode(self.api_key_ciphertext),
            "encrypted_api_key_nonce": _b64encode(self.api_key_nonce),
            "encrypted_api_secret": _b64encode(self.api_secret_ciphertext),
            "encrypted_api_secret_nonce": _b64encode(self.api_secret_nonce),
        }

    @classmethod
    def from_secret_data(cls, data: Dict[str, str]) -> "EncryptedSecretEnvelope":
        try:
            version = _b64decode(data["encryption_version"]).decode("utf-8")
            kms_key_id = _b64decode(data["kms_key_id"]).decode("utf-8")
            encrypted_data_key = _b64decode(data["encrypted_data_key"])
            encryption_context = _b64decode(data.get("encryption_context", ""))
            api_key_ciphertext = _b64decode(data["encrypted_api_key"])
            api_key_nonce = _b64decode(data["encrypted_api_key_nonce"])
            api_secret_ciphertext = _b64decode(data["encrypted_api_secret"])
            api_secret_nonce = _b64decode(data["encrypted_api_secret_nonce"])
        except KeyError as exc:  # pragma: no cover - defensive guard
            raise EncryptionError("Encrypted secret payload missing required fields") from exc
        return cls(
            kms_key_id=kms_key_id,
            encrypted_data_key=encrypted_data_key,
            encryption_context=encryption_context,
            api_key_nonce=api_key_nonce,
            api_key_ciphertext=api_key_ciphertext,
            api_secret_nonce=api_secret_nonce,
            api_secret_ciphertext=api_secret_ciphertext,
            version=version,
        )


@dataclass
class DecryptedCredentials:
    api_key: str
    api_secret: str


class EnvelopeEncryptor:
    """Utility for encrypting and decrypting Kraken credentials."""

    def __init__(self, kms: LocalKMSEmulator | None = None) -> None:
        self._kms = kms or LocalKMSEmulator()

    def encrypt_credentials(
        self,
        account_id: str,
        *,
        api_key: str,
        api_secret: str,
    ) -> EncryptedSecretEnvelope:
        context = {"account_id": account_id}
        data_key = self._kms.generate_data_key(context=context)
        aesgcm = AESGCM(data_key.plaintext)

        api_key_nonce = os.urandom(12)
        api_secret_nonce = os.urandom(12)
        api_key_ciphertext = aesgcm.encrypt(api_key_nonce, api_key.encode("utf-8"), data_key.context)
        api_secret_ciphertext = aesgcm.encrypt(
            api_secret_nonce,
            api_secret.encode("utf-8"),
            data_key.context,
        )
        return EncryptedSecretEnvelope(
            kms_key_id=data_key.kms_key_id,
            encrypted_data_key=data_key.encrypted,
            encryption_context=data_key.context,
            api_key_nonce=api_key_nonce,
            api_key_ciphertext=api_key_ciphertext,
            api_secret_nonce=api_secret_nonce,
            api_secret_ciphertext=api_secret_ciphertext,
        )

    def decrypt_credentials(
        self,
        account_id: str,
        envelope: EncryptedSecretEnvelope,
    ) -> DecryptedCredentials:
        context = {"account_id": account_id}
        data_key = self._kms.decrypt_data_key(encrypted=envelope.encrypted_data_key, context=context)
        aesgcm = AESGCM(data_key)
        api_key = aesgcm.decrypt(
            envelope.api_key_nonce,
            envelope.api_key_ciphertext,
            envelope.encryption_context,
        ).decode("utf-8")
        api_secret = aesgcm.decrypt(
            envelope.api_secret_nonce,
            envelope.api_secret_ciphertext,
            envelope.encryption_context,
        ).decode("utf-8")
        return DecryptedCredentials(api_key=api_key, api_secret=api_secret)


class SecretsMetadataStore:
    """In-memory emulation of ``secrets_meta`` table for metadata tracking."""

    _records: ClassVar[list[Dict[str, Any]]] = []

    def __init__(self, *, account_id: str) -> None:
        self.account_id = account_id

    def record_rotation(self, *, kms_key_id: str, last_rotated: datetime) -> Dict[str, Any]:
        entry = {
            "account_id": self.account_id,
            "kms_key_id": kms_key_id,
            "last_rotated": last_rotated,
            "ts": datetime.now(timezone.utc),
        }
        self._records.append(entry)
        return dict(entry)

    @classmethod
    def latest(cls, account_id: str) -> Optional[Dict[str, Any]]:
        relevant = [entry for entry in cls._records if entry["account_id"] == account_id]
        if not relevant:
            return None
        latest = max(relevant, key=lambda entry: entry["ts"])
        return dict(latest)

    @classmethod
    def all(cls) -> Iterable[Dict[str, Any]]:
        for entry in cls._records:
            yield dict(entry)


__all__ = [
    "DataKey",
    "DecryptedCredentials",
    "EncryptedSecretEnvelope",
    "EnvelopeEncryptor",
    "LocalKMSEmulator",
    "SecretsMetadataStore",
    "EncryptionError",
]
