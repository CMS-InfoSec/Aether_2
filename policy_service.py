"""FastAPI microservice exposing a policy decision endpoint."""

from __future__ import annotations

from typing import Any, Dict, Optional

from fastapi import FastAPI, HTTPException, status
from pydantic import BaseModel, Field, ValidationError

try:  # pragma: no cover - registry may be optional in some environments
    import model_registry  # type: ignore
except ImportError:  # pragma: no cover
    model_registry = None  # type: ignore


class PolicyDecisionRequest(BaseModel):
    """Request payload for the policy decision endpoint."""

    account_id: str = Field(..., description="Unique trading account identifier")
    symbol: str = Field(..., description="Instrument symbol to make a decision on")
    features: Dict[str, float] = Field(
        default_factory=dict,
        description="Feature dictionary consumed by the policy model",
    )
    book_snapshot: Dict[str, Any] = Field(
        default_factory=dict,
        description="Market microstructure snapshot (e.g. spread, imbalance)",
    )
    account_state: Dict[str, Any] = Field(
        default_factory=dict,
        description="Account state such as positions, pnl, and risk metrics",
    )


class PolicyDecisionResponse(BaseModel):
    """Structured policy decision produced by the service."""

    action: str = Field(..., description="High level action (enter, exit, hold, etc.)")
    side: str = Field(..., description="Side of the action (buy, sell, none)")
    qty: float = Field(..., description="Quantity to trade for the action")
    type: str = Field(..., description="Order type recommended by the model")
    limit_px: Optional[float] = Field(
        default=None, description="Optional limit price for limit orders"
    )
    tif: Optional[str] = Field(
        default=None, description="Optional time-in-force for the order"
    )
    tp: Optional[float] = Field(
        default=None, description="Optional take-profit price level"
    )
    sl: Optional[float] = Field(
        default=None, description="Optional stop-loss price level"
    )
    trailing: Optional[float] = Field(
        default=None, description="Optional trailing amount or percent"
    )
    expected_edge_bps: float = Field(
        ..., description="Expected edge in basis points for the recommendation"
    )
    expected_cost_bps: float = Field(
        ..., description="Expected execution cost in basis points"
    )
    confidence: float = Field(
        ..., description="Confidence score associated with the recommendation"
    )


app = FastAPI(title="Policy Service")


@app.post(
    "/policy/decide",
    response_model=PolicyDecisionResponse,
    status_code=status.HTTP_200_OK,
)
async def decide_policy(request: PolicyDecisionRequest) -> PolicyDecisionResponse:
    """Return a policy decision generated by the latest model for the account."""

    if model_registry is None or not hasattr(model_registry, "get_latest_model"):
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Model registry is unavailable",
        )

    try:
        model = model_registry.get_latest_model(  # type: ignore[attr-defined]
            account_id=request.account_id,
            symbol=request.symbol,
        )
    except TypeError:
        # Some registries may not accept keyword arguments; fall back to positional.
        model = model_registry.get_latest_model(request.account_id, request.symbol)  # type: ignore[misc]
    except Exception as exc:  # pragma: no cover - defensive for runtime issues
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Failed to load policy model",
        ) from exc

    if model is None or not hasattr(model, "predict"):
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="No suitable policy model available",
        )

    try:
        result = model.predict(  # type: ignore[attr-defined]
            account_id=request.account_id,
            symbol=request.symbol,
            features=request.features,
            book_snapshot=request.book_snapshot,
            account_state=request.account_state,
        )
    except NotImplementedError:
        result = None
    except Exception as exc:  # pragma: no cover - runtime inference errors
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Policy model inference failed",
        ) from exc

    if result is None:
        result = {
            "action": "hold",
            "side": "none",
            "qty": 0.0,
            "type": "market",
            "limit_px": None,
            "tif": None,
            "tp": None,
            "sl": None,
            "trailing": None,
            "expected_edge_bps": 0.0,
            "expected_cost_bps": 0.0,
            "confidence": 0.0,
        }

    if not isinstance(result, dict):
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Model returned an unexpected payload",
        )

    try:
        return PolicyDecisionResponse(**result)
    except ValidationError as exc:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Model response failed validation",
        ) from exc
